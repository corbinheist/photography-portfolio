---
/**
 * PhotoGrid — renders photos in the album's chosen layout:
 * - masonry: Pinterest-style, natural aspect ratios
 * - grid: Uniform aspect ratio grid
 * - horizontal-scroll: Lando Norris-style horizontal strip (GSAP ScrollTrigger)
 */

import Photo from './Photo.astro';

interface PhotoData {
  id: string;
  data: {
    title: string;
    url: string;
    width: number;
    height: number;
    lqip: string;
  };
}

interface Props {
  photos: PhotoData[];
  layout?: 'masonry' | 'grid' | 'horizontal-scroll';
  gridAspectRatio?: string;
  sizes?: string;
}

const { photos, layout = 'masonry', gridAspectRatio = '3:2', sizes } = Astro.props;

// Parse aspect ratio for grid layout
const [arW, arH] = gridAspectRatio.split(':').map(Number);
const aspectPadding = arH && arW ? (arH / arW) * 100 : 66.67;
---

{layout === 'masonry' && (
  <div class="masonry-grid" data-masonry-grid>
    {photos.map((photo, i) => (
      <div class="masonry-item">
        <Photo
          url={photo.data.url}
          width={photo.data.width}
          height={photo.data.height}
          lqip={photo.data.lqip}
          alt={photo.data.title}
          sizes={sizes || "(max-width: 640px) 100vw, (max-width: 1024px) 50vw, (max-width: 1440px) 33vw, 25vw"}
          lightboxIndex={i}
        />
      </div>
    ))}
  </div>
)}

{layout === 'grid' && (
  <div class="uniform-grid stagger-children">
    {photos.map((photo, i) => (
      <div class="grid-item" style={`--aspect-padding: ${aspectPadding}%`}>
        <Photo
          url={photo.data.url}
          width={photo.data.width}
          height={photo.data.height}
          lqip={photo.data.lqip}
          alt={photo.data.title}
          sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
          lightboxIndex={i}
        />
      </div>
    ))}
  </div>
)}

{layout === 'horizontal-scroll' && (
  <div class="horizontal-scroll" data-horizontal-scroll>
    <div class="scroll-track" data-scroll-track>
      {photos.map((photo, i) => (
        <div class="scroll-item">
          <Photo
            url={photo.data.url}
            width={photo.data.width}
            height={photo.data.height}
            lqip={photo.data.lqip}
            alt={photo.data.title}
            sizes="80vw"
            loading={i === 0 ? 'eager' : 'lazy'}
            lightboxIndex={i}
          />
        </div>
      ))}
    </div>
  </div>
)}

<style>
  /* ==========================================
     Masonry Layout
     ========================================== */
  .masonry-grid {
    columns: 1;
    column-gap: var(--space-md);
    padding: var(--space-md) 0;
  }

  @media (min-width: 640px) {
    .masonry-grid {
      columns: 2;
    }
  }

  @media (min-width: 1024px) {
    .masonry-grid {
      columns: 3;
    }
  }

  @media (min-width: 1440px) {
    .masonry-grid {
      columns: 4;
    }
  }

  .masonry-item {
    break-inside: avoid;
    margin-bottom: var(--space-md);
  }

  /* ==========================================
     Uniform Grid Layout
     ========================================== */
  .uniform-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--space-md);
    padding: var(--space-md) 0;
  }

  @media (min-width: 640px) {
    .uniform-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (min-width: 1024px) {
    .uniform-grid {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  .grid-item {
    position: relative;
    padding-bottom: var(--aspect-padding);
    overflow: hidden;
  }

  .grid-item :global(.photo-wrap) {
    position: absolute;
    inset: 0;
  }

  .grid-item :global(.photo-img) {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* ==========================================
     Horizontal Scroll Layout
     ========================================== */
  .horizontal-scroll {
    height: 100vh;
    overflow: hidden;
  }

  .scroll-track {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    height: 100%;
    padding: var(--space-xl);
    width: max-content;
  }

  .scroll-item {
    flex-shrink: 0;
    height: 80vh;
  }

  .scroll-item :global(.photo-img) {
    height: 100%;
    width: auto;
    object-fit: contain;
  }
</style>

<script>
  /**
   * Reorder masonry items so CSS columns (which fill top→bottom)
   * produce left→right reading order instead of column-by-column.
   *
   * CSS columns place items sequentially down each column. To get L→R order,
   * we "deal" items like cards: item 0→col1, item 1→col2, etc. then wrap.
   * This means we need to reorder the DOM so that positions 0, numCols, 2*numCols...
   * come first (they'll fill column 1), then 1, numCols+1, 2*numCols+1... (column 2), etc.
   */
  function reorderMasonry() {
    document.querySelectorAll<HTMLElement>('[data-masonry-grid]').forEach((grid) => {
      const items = Array.from(grid.children) as HTMLElement[];
      if (items.length <= 1) return;

      const numCols = Math.round(grid.offsetWidth / items[0].offsetWidth) || 1;
      if (numCols <= 1) return;

      // Calculate how many items per column
      const rows = Math.ceil(items.length / numCols);

      // Build new order: for L→R reading, item at visual position (row, col)
      // needs to be at DOM index (col * rows + row) so CSS columns places it correctly.
      // Inverse: DOM index i should show the item from visual position:
      //   col = i / rows, row = i % rows → visual index = row * numCols + col
      const reordered: HTMLElement[] = [];
      for (let i = 0; i < rows * numCols; i++) {
        const col = Math.floor(i / rows);
        const row = i % rows;
        const visualIndex = row * numCols + col;
        if (visualIndex < items.length) {
          reordered.push(items[visualIndex]);
        }
      }

      // Apply reorder
      reordered.forEach((item) => grid.appendChild(item));
    });
  }

  // Run after page loads and layout is computed
  if (document.readyState === 'complete') {
    reorderMasonry();
  } else {
    window.addEventListener('load', reorderMasonry);
  }
</script>
